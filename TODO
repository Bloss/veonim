NEW HARDER FASTER STRONGER ICON
consider adding brunswick theme as default. when rebrand with new logo?

spammy cmd-update lolwut?

canvasWindow clearReact math.ceil instead of floor. render artifacts on left and right
edges. use ── ──── to test
  - should use clip/rect to draw thingies? perf impact?

hide overlays (problem info, hover) on bufleave
  - happens when switch tabs

ok i guess i misunderstood how keys work... or there is a bug?
when using keys in hyperapp lists, and clearing parts of the list,
not all removed items are actually removed from the dom. so we end
up with a mix of new and old items in the DOM. lolwut?

grep: i don't like the large/small icon unaligned padding/margins in query/filter inputs

new extension process - use pipes? bridge and create client with proxy, etc.

adapter:
 -symbols, get rid of  toVimLocation

grep:
  - i'm not sure that we load all the results (in some cases - try searching
    for a popular keyword like 'await'). i think there is some logic to load
    more results from cache once we scroll down... maybe that is not activated
    if the div container height is too high?

build.js not being used for anything. gonna finish it or discard?

should font-sizer be part of build process?

create a simple hyperapp virtualized list component that simply renders dom nodes
  given a slice of the list. you want the top of the list, slice(0, 10)
  you want the end, slice(list.length - 10), etc. no mouse support for now.
  keep it simple and easy. make it composable (vs higher order?/wrapping?)

files not refresh after delete file

STOP REQUIRING SO MUCH SHIT ON APP START LOL
  - lazy load more shit
  - web worker more shit (ai)

depmgr as separate process (not even worker thread) - because of security and isolation?


- SHADOW BUFFERS -
the problem with shadow buffers is that our current neovim window render strategy
just picks a random html div and does its thing. we need to be semantic and render
windwos to specific divs. we need to associate a specific div with a specific vim
window and maintain that relationship so that shadow buffers are tied to the correct
html element.

if we assign a div to each window, how will this work with tabpage switch? right now it's
super clean and performant as the div elements are reused/not modified
  - what if tab switch to the exact same windows, but just swapped around in layout order
    - file1 + file2 -> file2 + file1

shadow buffers:
cursor.ts does not recognize current window as shadow-buffer-type anymore... what changed?
re-ordering windows fail - try creating new split when a shadow buffer already open

what to do when shadow buffer component goes back to normal mode?? need to display
some sort of visual feedback. don't move cursor around etc. maybe also disable notifications

// TODO: in addition to close/rename, we also need to detect when a window gets reassigned
// and unload/reload shadow buffer. window container elements do not follow vim windows

are we still resizing inappropriately?
try to see what happens with NERDTree when open a layout like this
left nerd, middle two horizontal splits, right open ;ve
| | | |
|-|-|-|
| | | |
does it get resized equally?

embed-explorer:
<tab> key is doing something weird. check on it
  - e.preventDefault?
add action to open file in LAST/ALTERNATE buffer, NOT the current one!
don't auto select (active: ix === $.ix) an item in the list unless we have focus
redo home, next, prev keybinds for explorer to not use ctrl + hjkl
figure out better name for embed custom render buffers
generalize embed buffers to support any components
figure out how to swap between different embed components (get buffer name?)
can we support multiple embed components, one per each buffer instance? or shared?
nameplate title changes on window change

--

should probably stop auto adjusting windows with (wincmd =)
  this is immediatly obvious now with non-equal width windows (embed explorer)
  can we be smarter about this? maybe figure out widths before resize grid?
  only apply wincmd = in certain conditions?

check on the background of embed explorer, not sure it's the exact same bg color as vim.bg
- using digital color meter.app it is confirmed that the colors are slightly
  off. i checked the logic for setting background is being set correct. in
  fact, when i took the exact bg color specified in the colorscheme.vim and
  applied it directly to the element background color, the subtle color
  difference still persisted. i wonder if the color convert for canvas is doing
  something slightly off. or perhaps html divs have some sort of color profile
  applied but canvas do not...

rpc errors send to notifications? (try calling some broken execute() vimscript from usermenu)

readme screen showcase automation
  create demo script to start electron at a certain size
  open various features
  use electron/spectron screenshot feature
  save to docs

  - showcase/demo fuzzy buffer find in docs
  - showcase/demo quickfix

upgrade ripgrep

--ideas--

should there be a 'deactivated/unfocused' style of cursor? i.e. when jumping between Problems
or references, instead of (right now) only showing cursorline, also show the actual cursor block
but perhaps faded out, in such a way to indicate that there is no focus in the vim window...?

make a different cursor for shadow buffers to signify normal mode?

super cool start page with mru projects and shit

move messages to bottom | top right corners. pimp them out to loook dope & lit AF

change object key or value vim function/macro binding

image preview buffers

i want the ability to be able to record multiple macros and name them. i want some sort of visual
selector gui so i can retrieve and rerun macros without having to remember what macro register
i saved, and what the usage for a particular macro is supposed to be. this can work similar
to the marks popup idea below

create find overlay at the top or bottom of current window (like xcode/vscode/atom/sublime/etc). used for builtin vim / or ? and can be used by custom components (viewport fuzzy search)
  - maybe the design can integrate somehow with the buffer fuzzy search list

set process.env.XDG_CONFIG_HOME in dev to use alt vim/extensions folders when testing dev that do not conflict with release builds

easymotion show bigger letters + show WHILE searching ooooooo

constrain overlay menus to a particular window (current window)
  - (if it makes sense to be local - some might be global - like user menus or project switcher)
  - i.e. show symbol/file menu on top of the current buffer window, instead of the center of the program,
    since selecting a symbol or file will make changes in the current window, not globally
start splash screen include MRU projects
easymotion jump to highlighted word
buffer-search should only search in the current viewport. no scrolling pls
create fuzzy search for entire buffer, but use popup menu
terminal change title to current running process
backfill problems into quickfix list

:: try with new floating windows api for this? then it can all be supported in vimscript

press and hold mark ' keybind to bring up menu of current global marks
menu lists something like
a - support.ts
s - utils.ts
d - main.ts

pressing one of the keys takes you to that file
releasing mark keybind closes menu without any navigation
(think kinda like opie addon, but hold activate)

- mru file jump list
the use case is that i may be jumping thru files either via...
  - goto definition
  - find references

...and i want to go back to the original starting point. the trick is that the
jump list may have other intermediary jumps, so that's not good enough, as i
may have to hit multiple times c-o to go back to origin point.

marks are also not good because i may forget to set them, and sometimes i may
decide to go back to a different origin point (or not all the way up the jump
list chain)

there is go to previous buffer (:b# i think) - but in my testing it does not
seem to function the way i thought it would. plus, if i do indeed side track as
a tangent to another buffer, then this previous buffer process will be
incorrect


-- auto close stale terminal buffers? i.e. if there is no running process in
bash, then if i navigate to a non-term buffer, auto-close the terminal session?
(start new ones instead of switching back). this might solve the problem of
having to remember exactly which terminal might be available for use? right now
terminals are difficult to discern as they just have random numbers, but in the
future if we can name running process in term, thennnnnnnn

multi-monitor support? with shada and edge detection (when c-w l on right most window, go to next monitor)


add some sort of error checking/timeout for using lang serv actions, but if the
lang is not loaded yet or requests are taking too long? i.e. calling typescript
find-symbols in a large project (like veonim) after starting up veonim
- or even if the langserv doesn't exist. show some info?


jump to previous/next edit location g; make it repeatable with key-hold transforms pls kthx


use floating window for terminal scratch buffer. say i want to type a super fancy and long
git commit msg, open scratch buffer, do the edits and whatnot, then "save" buffer to terminal
prompt

-- more stuffffffff
delete till highlighted text

create marks from visual selection

display marks visually in editor

when using search substitution with regex, define a working area before hand with visual to marks
create marks from operator

i.e. mio for mark inner object then :%s a word and replace only in the defined area

similarly can do for dot operator with replace cgn 

change a word then repeat that change within the range of an operator:
cm on word then dot on an operator: in object - like pressing .io maybe (repeat in object)

can replace cw and ciw to always allow repeat again (do cm behind the scenes)

macros/fns/operators for:
replace obj key and val
replace func body

depmgr as separate process: security - no access to electron

auto add to quick fix list:
references
problems
grep 

macro to delete surrounding block {}
like:
if (blarg) {
  stuff
  moreStuff()
}

delete lines 0 and 3


-
look into how we can use v8 snapshots for startup speed
https://github.com/atom/electron-link
https://www.npmjs.com/package/electron-mksnapshot
https://github.com/atom/atom/blob/f48069c5f848b5ae624b110a1df7800e919eb142/src/native-compile-cache.js
https://flight-manual.atom.io/behind-atom/sections/how-atom-uses-chromium-snapshots/
https://github.com/atom/atom/blob/d9ebd7e125d5f07def1a057a0a8278d4d9d7d23a/script/lib/generate-startup-snapshot.js#L19-L65
